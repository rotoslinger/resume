<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Resume - Three.js</title>
    <link rel="stylesheet" href="./style.css" />
  </head>
  <body>
    <div id="app">
      <canvas id="three-canvas"></canvas>
      <div class="ui-overlay">
        <header class="header">
          <h1>Interactive Resume</h1>
          <p>Welcome to my 3D portfolio experience</p>
        </header>
        <div class="controls">
          <button id="rotate-btn">Toggle Rotation</button>
          <button id="color-btn">Change Color</button>
        </div>
      </div>
    </div>
    
    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
      // Scene setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('three-canvas'),
        antialias: true,
        alpha: true
      });

      // Configure renderer
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setClearColor(0x000000, 0);

      // Load the GLB model
      const loader = new THREE.GLTFLoader();
      let character = null;

      // Create a fallback cube in case the model doesn't load
      const fallbackGeometry = new THREE.BoxGeometry(1, 2, 0.5);
      const fallbackMaterial = new THREE.MeshBasicMaterial({ color: 0x4ecdc4 });
      const fallbackCube = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
      fallbackCube.position.set(0, 0, 0);
      scene.add(fallbackCube);

      loader.load('./ManInSuit.glb', (gltf) => {
        character = gltf.scene;
        
        // Scale and position the character
        character.scale.set(1, 1, 1);
        character.position.set(0, -1, 0);
        
        // Remove fallback cube and add character
        scene.remove(fallbackCube);
        scene.add(character);
        console.log('Character loaded successfully!');
      }, undefined, (error) => {
        console.error('Error loading character:', error);
        console.log('Using fallback cube instead');
      });

      // Create a simple ground plane
      const groundGeometry = new THREE.PlaneGeometry(10, 10);
      const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -1;
      scene.add(ground);

      // Simple ambient lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);

      // Position camera
      camera.position.z = 5;

      // Animation variables
      let isRotating = true;
      let animationTime = 0;

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        
        animationTime += 0.01;
        
        if (isRotating) {
          if (character) {
            // Gentle rotation for the character
            character.rotation.y += 0.005;
            // Subtle floating animation
            character.position.y = -1 + Math.sin(animationTime) * 0.1;
          } else {
            // Animate fallback cube
            fallbackCube.rotation.x += 0.01;
            fallbackCube.rotation.y += 0.01;
          }
        }
        
        animateParticles();
        renderer.render(scene, camera);
      }

      // Event listeners
      document.getElementById('rotate-btn').addEventListener('click', () => {
        isRotating = !isRotating;
        document.getElementById('rotate-btn').textContent = isRotating ? 'Stop Animation' : 'Start Animation';
      });

      document.getElementById('color-btn').addEventListener('click', () => {
        // Cycle through different ambient light colors
        const lightColors = [0xffffff, 0x4ecdc4, 0xff6b6b, 0x45b7d1, 0xfeca57];
        const currentColor = ambientLight.color.getHex();
        const currentIndex = lightColors.indexOf(currentColor);
        const nextIndex = (currentIndex + 1) % lightColors.length;
        ambientLight.color.setHex(lightColors[nextIndex]);
      });

      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Add some floating particles for visual interest
      const particleGeometry = new THREE.BufferGeometry();
      const particleCount = 100;
      const positions = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 20;
      }

      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const particleMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.02,
        transparent: true,
        opacity: 0.6
      });

      const particles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particles);

      // Animate particles
      function animateParticles() {
        const positions = particles.geometry.attributes.position.array;
        
        for (let i = 1; i < positions.length; i += 3) {
          positions[i] += 0.01; // Move particles up
          if (positions[i] > 10) {
            positions[i] = -10; // Reset to bottom
          }
        }
        
        particles.geometry.attributes.position.needsUpdate = true;
      }

      // Start animation
      animate();
    </script>
  </body>
</html>
